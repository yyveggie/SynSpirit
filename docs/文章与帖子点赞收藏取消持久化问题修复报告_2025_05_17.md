# 文章详情页点赞与收藏取消无法持久化问题修复报告

**日期：2025-05-17**

## 一、问题概述

在文章详情页，用户对文章进行点赞和收藏操作时，新增（点赞/收藏）可以正常持久化，但**取消点赞或取消收藏后，刷新页面状态无法同步，表现为"取消"操作未被记忆**，用户体验受影响。

## 二、问题排查过程

1. **后端排查**
   - 检查了后端 `UserAction` 表和 `ActionInteraction` 表的相关逻辑，发现取消操作时仅做了软删除（`is_deleted=True`），而计数统计时只统计未软删除的记录。
   - 但实际数据库中相关记录并未被物理删除，导致某些前端状态依赖的接口未能正确反映最新状态。
   - Celery 异步任务 `update_article_counts`、`update_post_counts` 能正确统计计数，但前端页面未能及时同步。

2. **前端排查**
   - 前端使用了 React Query（TanStack Query）做缓存，且有"防止循环刷新"的特殊处理，导致取消操作后未主动刷新文章详情数据。
   - 日志显示：`[useCollectArticle Settled] Skip invalidating queries to prevent refresh loops`，即取消了缓存失效，页面数据未及时更新。

## 三、核心问题总结

- **后端问题**：取消点赞/收藏时仅软删除，部分接口和计数逻辑未能完全同步，且未物理删除相关记录。
- **前端问题**：操作后未强制刷新详情数据，导致页面状态与后端不一致。

## 四、最终解决方案

1. **后端修复**
   - 将 `delete_action`、`unlike_action`、`uncollect_action` 等接口中的删除逻辑由软删除改为物理删除，确保数据库中相关记录彻底移除。
   - 删除后，立即触发 Celery 计数更新任务，保证计数字段与实际数据一致。
   - 优化了 UserAction 记录的查找逻辑，确保所有相关点赞/收藏记录都能被正确删除。

2. **前端修复**
   - 在 `useLikeArticle` 和 `useCollectArticle` 的 `onSettled` 回调中，添加 `queryClient.refetchQueries`，强制刷新文章详情数据，确保页面状态与后端同步。
   - 保留乐观更新，提升用户体验，但操作完成后始终以后端数据为准。

## 五、修复效果

- 现在，用户在文章详情页取消点赞或收藏后，页面会自动刷新，状态与数据库保持一致。
- 计数和按钮状态均能正确反映用户的最新操作。
- 彻底解决了"取消操作无法持久化"的问题。

---

你的理解很准确，**问题的关键之一确实在于 TanStack Query（React Query）前端缓存机制的配置和使用方式**。

### 详细解释

#### 1. **TanStack Query 的缓存机制本身没有问题**  
TanStack Query 设计的初衷就是通过缓存减少不必要的网络请求、提升页面响应速度，并且支持“乐观更新”等高级用法。

#### 2. **本项目中的具体问题**  
- 由于前端为了防止“无限刷新循环”，**在点赞/收藏取消操作后，主动跳过了缓存失效（invalidate）或数据强制刷新（refetch）**，导致页面数据没有及时与后端同步。
- 这在日志中有明确体现：  
  ```
  [useCollectArticle Settled] Skip invalidating queries to prevent refresh loops
  ```
- 这样一来，虽然后端数据已经变更，但前端页面依然显示旧的缓存数据，用户看到的状态就不对了。

#### 3. **根本原因总结**
- **不是 TanStack Query 的机制有bug，而是“如何用好它”**：  
  - 如果操作后不刷新数据，缓存就会“记住”旧状态，导致前端和后端不一致。
  - 只要在操作后适时调用 `refetchQueries` 或 `invalidateQueries`，就能保证数据同步。

#### 4. **最终修复办法**
- 在每次点赞/收藏取消操作后，**强制刷新文章详情数据**，让前端缓存与后端保持一致。
- 这样既能享受缓存带来的性能提升，又不会出现数据不同步的问题。

---

**一句话总结**：  
> 问题不是 TanStack Query 的机制本身，而是“操作后没有及时刷新缓存”，导致前端状态与后端不一致。只要用好它的刷新能力，缓存机制依然是高效且可靠的。
