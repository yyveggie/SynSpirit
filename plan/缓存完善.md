
## 数据缓存(DataCache)的应用场景

数据缓存主要用于缓存频繁访问的API响应和数据库查询结果，可减轻数据库负担。例如：

1. **文章列表查询缓存**
```python
# 缓存首页热门文章列表，有效期5分钟
@DataCache.cached(KEY_PREFIX['ARTICLE'], TTL['DATA_MEDIUM'])
def get_hot_articles(limit=10):
    # 复杂的SQL查询获取热门文章
    articles = Article.query.order_by(Article.view_count.desc()).limit(limit).all()
    return [article.to_dict() for article in articles]
```

2. **用户信息缓存**
```python
# 缓存用户资料，有效期10分钟
@DataCache.cached(KEY_PREFIX['USER'], TTL['USER'])
def get_user_profile(user_id):
    user = User.query.get(user_id)
    return user.to_dict() if user else None
```

3. **标签云数据缓存**
```python
# 缓存标签云数据，有效期1小时
@DataCache.cached(KEY_PREFIX['DATA'], TTL['DATA_LONG'])
def get_tags_cloud():
    # 聚合查询获取热门标签
    tags = db.session.query(Tag.name, func.count(Tag.id)).join(...).group_by(...).all()
    return [{'name': tag[0], 'count': tag[1]} for tag in tags]
```

## 计数缓存(CounterCache)的应用场景

计数缓存用于高频修改的计数器数据，避免频繁更新数据库。例如：

1. **文章点赞计数**
```python
# 增加文章点赞数
def like_article(article_id, user_id):
    # 数据库记录点赞关系
    like = ArticleLike(user_id=user_id, article_id=article_id)
    db.session.add(like)
    db.session.commit()
    
    # 更新缓存中的点赞计数，原子操作
    new_count = CounterCache.increment('likes', 'article', article_id)
    return new_count
```

2. **评论数量统计**
```python
# 添加评论后更新评论计数
def add_comment(article_id, user_id, content):
    # 数据库添加评论
    comment = Comment(user_id=user_id, article_id=article_id, content=content)
    db.session.add(comment)
    db.session.commit()
    
    # 更新缓存中的评论计数
    new_count = CounterCache.increment('comments', 'article', article_id)
    return comment, new_count
```

3. **用户浏览量统计**
```python
# 记录文章浏览，增加浏览计数
def view_article(article_id, user_id):
    # 可能在数据库记录一次浏览
    
    # 增加缓存中的浏览计数
    # 即使高并发访问也能保证计数准确
    view_count = CounterCache.increment('views', 'article', article_id)
    return view_count
```

这些缓存方式可以显著提高系统性能，特别是在高并发场景下。计数缓存使用Redis的原子操作特性，确保计数准确性，同时大幅减少数据库写入压力。
